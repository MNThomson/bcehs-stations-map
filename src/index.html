<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="darkreader-lock">
    <title>BCEHS Stations Map</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Interactive map of all BC Emergency Health Services (BCEHS) ambulance stations in British Columbia, Canada. Find station locations, addresses, and types including regular stations, dispatch centers, critical care transport, and annexes.">
    <meta name="keywords" content="BCEHS, BC ambulance stations, BC Emergency Health Services, ambulance locations British Columbia, EMS stations BC">
    <link rel="canonical" href="https://bcehs.mnt.dev">

    <!-- Open Graph -->
    <meta property="og:title" content="BCEHS Stations Map - BC Emergency Health Services Locations">
    <meta property="og:description" content="Interactive map of all BC Emergency Health Services ambulance stations in British Columbia, Canada.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://bcehs.mnt.dev">
    <meta property="og:image" content="https://images.unsplash.com/photo-1697952431905-9c8d169d9d2b?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNDA2MjZ8MHwxfHNlYXJjaHwyfHxiYyUyMGFtYnVsYW5jZXxlbnwwfHx8fDE3NjQ5ODQxMDB8MA&ixlib=rb-4.1.0&q=80&w=1080">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="BCEHS Stations Map">
    <meta name="twitter:description" content="Interactive map of all BCEHS ambulance stations in British Columbia.">
    <meta name="twitter:image" content="https://images.unsplash.com/photo-1697952431905-9c8d169d9d2b?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNDA2MjZ8MHwxfHNlYXJjaHwyfHxiYyUyMGFtYnVsYW5jZXxlbnwwfHx8fDE3NjQ5ODQxMDB8MA&ixlib=rb-4.1.0&q=80&w=1080">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "BCEHS Stations Map",
        "description": "Interactive map of BC Emergency Health Services ambulance stations",
        "url": "https://bcehs.mnt.dev",
        "applicationCategory": "MapApplication",
        "operatingSystem": "Web Browser"
    }
    </script>

    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üöë</text></svg>">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Light mode (default) */
            --bg-dark: #f5f7fa;
            --bg-card: #ffffff;
            --bg-card-alt: #f8fafc;
            --bg-input: #f8fafc;
            --bg-hover: #f1f5f9;
            --accent-red: #dc2626;
            --accent-orange: #ea580c;
            --accent-orange-dark: #c2410c;
            --accent-blue: #2563eb;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --shadow-sm: rgba(0, 0, 0, 0.08);
            --shadow-md: rgba(0, 0, 0, 0.1);
            --shadow-lg: rgba(0, 0, 0, 0.15);
            --shadow-xl: rgba(0, 0, 0, 0.2);
            --overlay-bg: rgba(0, 0, 0, 0.4);
            --muted-marker: #9ca3af;
            --btn-active-text: #fff;

            /* Tag colors - light mode */
            --tag-cp-bg: rgba(220, 38, 38, 0.1);
            --tag-cp-text: #b91c1c;
            --tag-soc-bg: rgba(234, 88, 12, 0.1);
            --tag-soc-text: #c2410c;
            --tag-annex-text: #4b5563;
            --tag-dispatch-text: #15803d;
            --tag-special-text: #a16207;
            --tag-cct-text: #b91c1c;
            --tag-laat-bg: rgba(37, 99, 235, 0.1);
            --tag-laat-text: #1d4ed8;

            /* Station type colors */
            --type-station: #004a8d;
            --type-annex: #6b7280;
            --type-dispatch: #22c55e;
            --type-special: #ffd000;
            --type-cct: #ec1c24;
        }

        /* Dark mode (applied via JS based on system preference or user choice) */
        :root[data-theme="dark"] {
            --bg-dark: #0f1419;
            --bg-card: #1a1f26;
            --bg-card-alt: #242b35;
            --bg-input: #0f1419;
            --bg-hover: #242b35;
            --accent-red: #e63946;
            --accent-orange: #f4a261;
            --accent-orange-dark: #e67e22;
            --accent-blue: #457b9d;
            --text-primary: #f1faee;
            --text-secondary: #a8b2c1;
            --border-color: #2d3748;
            --shadow-sm: rgba(0, 0, 0, 0.2);
            --shadow-md: rgba(0, 0, 0, 0.3);
            --shadow-lg: rgba(0, 0, 0, 0.4);
            --shadow-xl: rgba(0, 0, 0, 0.5);
            --overlay-bg: rgba(0, 0, 0, 0.7);
            --muted-marker: #3a3f47;
            --btn-active-text: #000;

            /* Tag colors - dark mode */
            --tag-cp-bg: rgba(230, 57, 70, 0.2);
            --tag-cp-text: #ff6b7a;
            --tag-soc-bg: rgba(244, 162, 97, 0.2);
            --tag-soc-text: #f4a261;
            --tag-annex-text: #9ca3af;
            --tag-dispatch-text: #4ade80;
            --tag-special-text: #fde047;
            --tag-cct-text: #f87171;
            --tag-laat-bg: rgba(52, 152, 219, 0.2);
            --tag-laat-text: #5dade2;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-card-alt) 100%);
            padding: 1.25rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 1000;
            box-shadow: 0 1px 3px var(--shadow-sm);
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-red), var(--accent-orange), var(--accent-red));
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent-red), #c41e3a);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(230, 57, 70, 0.3);
        }

        .logo-text h1 {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .logo-text p {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .stats {
            display: flex;
            gap: 2rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--accent-orange);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #map {
            flex: 1;
            width: 100%;
            background: var(--bg-dark);
        }

        /* Custom popup styles */
        .leaflet-popup-content-wrapper {
            background: var(--bg-card);
            color: var(--text-primary);
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 10px 40px var(--shadow-lg);
            border: 1px solid var(--border-color);
        }

        .leaflet-popup-content {
            margin: 0;
            min-width: 300px;
        }

        .leaflet-popup-tip {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-top: none;
            border-left: none;
        }

        .popup-content {
            padding: 1rem;
        }

        .popup-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .popup-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .popup-icon.station { background: linear-gradient(135deg, var(--type-station), color-mix(in srgb, var(--type-station) 70%, black)); }
        .popup-icon.annex { background: linear-gradient(135deg, var(--type-annex), color-mix(in srgb, var(--type-annex) 70%, black)); }
        .popup-icon.dispatch { background: linear-gradient(135deg, var(--type-dispatch), color-mix(in srgb, var(--type-dispatch) 70%, black)); }
        .popup-icon.special { background: linear-gradient(135deg, var(--type-special), color-mix(in srgb, var(--type-special) 90%, white)); }
        .popup-icon.cct { background: linear-gradient(135deg, var(--type-cct), color-mix(in srgb, var(--type-cct) 70%, black)); }

        .popup-title {
            font-size: 1rem;
            font-weight: 600;
            line-height: 1.3;
        }

        .popup-location {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .popup-address {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            line-height: 1.5;
        }

        .popup-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
        }

        .tag {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .tag-cp { background: var(--tag-cp-bg); color: var(--tag-cp-text); }
        .tag-soc { background: var(--tag-soc-bg); color: var(--tag-soc-text); }
        .tag-annex { background: color-mix(in srgb, var(--type-annex) 15%, transparent); color: var(--tag-annex-text); }
        .tag-dispatch { background: color-mix(in srgb, var(--type-dispatch) 15%, transparent); color: var(--tag-dispatch-text); }
        .tag-special { background: color-mix(in srgb, var(--type-special) 15%, transparent); color: var(--tag-special-text); }
        .tag-cct { background: color-mix(in srgb, var(--type-cct) 15%, transparent); color: var(--tag-cct-text); }
        .tag-crs { background: color-mix(in srgb, var(--type-special) 15%, transparent); color: var(--tag-special-text); }
        .tag-laat { background: var(--tag-laat-bg); color: var(--tag-laat-text); }

        /* Wait times section */
        .wait-times-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
        }

        .wait-times-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.6rem;
        }

        .wait-times-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .wait-times-total {
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--accent-orange);
        }

        .wait-times-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .wait-time-item {
            background: color-mix(in srgb, var(--text-primary) 3%, transparent);
            border-radius: 8px;
            padding: 0.5rem;
            text-align: center;
        }

        .wait-time-item.priority-red {
            border-left: 3px solid #e63946;
        }

        .wait-time-item.priority-orange {
            border-left: 3px solid #f4a261;
        }

        .wait-time-item.priority-yellow {
            border-left: 3px solid #f1c40f;
        }

        .priority-label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-bottom: 0.3rem;
        }

        .priority-stats {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
        }

        .event-count {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .response-time {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        /* Year selector dropdown */
        .year-selector {
            position: relative;
        }

        .year-selector::after {
            content: '‚ñæ';
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--accent-orange);
            font-size: 0.7rem;
        }

        .year-select {
            appearance: none;
            -webkit-appearance: none;
            background: color-mix(in srgb, var(--text-primary) 5%, transparent);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.3rem 1.8rem 0.3rem 0.6rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent-orange);
            cursor: pointer;
            font-family: 'DM Sans', sans-serif;
            transition: all 0.15s ease;
        }

        .year-select:hover {
            background-color: color-mix(in srgb, var(--text-primary) 8%, transparent);
            border-color: var(--accent-orange);
        }

        .year-select:focus {
            outline: none;
            border-color: var(--accent-orange);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent-orange) 20%, transparent);
        }

        .year-select option {
            background: var(--bg-card);
            color: var(--text-primary);
            padding: 0.5rem;
        }

        .wait-times-total-row {
            margin-bottom: 0.5rem;
        }

        /* Aggregate data notice */
        .aggregate-notice {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            background: color-mix(in srgb, var(--accent-blue) 10%, transparent);
            border: 1px solid color-mix(in srgb, var(--accent-blue) 25%, transparent);
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            margin-bottom: 0.5rem;
        }

        .aggregate-icon {
            font-size: 0.8rem;
        }

        .aggregate-text {
            font-size: 0.7rem;
            color: var(--text-secondary);
            line-height: 1.3;
        }

        .aggregate-text strong {
            color: var(--accent-blue);
            font-weight: 600;
        }

        /* Co-located groups section */
        .colocated-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
        }

        .colocated-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .colocated-group {
            background: color-mix(in srgb, var(--text-primary) 3%, transparent);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.6rem;
            margin-bottom: 0.5rem;
        }

        .colocated-group:last-child {
            margin-bottom: 0;
        }

        .colocated-group-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .colocated-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        .colocated-icon.station { background: linear-gradient(135deg, var(--type-station), color-mix(in srgb, var(--type-station) 70%, black)); }
        .colocated-icon.annex { background: linear-gradient(135deg, var(--type-annex), color-mix(in srgb, var(--type-annex) 70%, black)); }
        .colocated-icon.dispatch { background: linear-gradient(135deg, var(--type-dispatch), color-mix(in srgb, var(--type-dispatch) 70%, black)); }
        .colocated-icon.special { background: linear-gradient(135deg, var(--type-special), color-mix(in srgb, var(--type-special) 90%, white)); }
        .colocated-icon.cct { background: linear-gradient(135deg, var(--type-cct), color-mix(in srgb, var(--type-cct) 70%, black)); }

        .colocated-name {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .colocated-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            margin-top: 0.3rem;
        }

        .colocated-tags .tag {
            font-size: 0.6rem;
            padding: 0.15rem 0.4rem;
        }

        /* Badge for co-located marker */
        .marker-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: var(--accent-orange);
            border-radius: 50%;
            font-size: 0.6rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--btn-active-text);
            border: 2px solid var(--bg-card);
            box-shadow: 0 2px 4px var(--shadow-md);
        }

        .custom-marker-wrapper {
            position: relative;
            display: inline-block;
        }

        /* Legend */
        .legend {
            visibility: hidden;
            width: fit-content;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 20px var(--shadow-md);
        }

        .leaflet-bottom .legend {
            visibility: visible;
        }

        .legend h3 {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.4rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .legend-marker {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-marker.station { background: var(--type-station); }
        .legend-marker.annex { background: var(--type-annex); }
        .legend-marker.dispatch { background: var(--type-dispatch); }
        .legend-marker.special { background: var(--type-special); }
        .legend-marker.cct { background: var(--type-cct); }

        /* Custom marker styles */
        .custom-marker {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .marker-pin {
            width: 24px;
            height: 24px;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .marker-pin.station { background: var(--type-station); }
        .marker-pin.annex { background: var(--type-annex); opacity: 0.7; }
        .marker-pin.dispatch { background: var(--type-dispatch); }
        .marker-pin.special { background: var(--type-special); }
        .marker-pin.cct { background: var(--type-cct); }

        .marker-inner {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            transform: rotate(45deg);
        }

        /* Zoom controls */
        .leaflet-control-zoom {
            border: none !important;
            box-shadow: 0 4px 15px var(--shadow-md) !important;
        }

        .leaflet-control-zoom a {
            background: var(--bg-card) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color) !important;
        }

        .leaflet-control-zoom a:hover {
            background: var(--bg-hover) !important;
        }

        .leaflet-control-zoom-in {
            border-radius: 8px 8px 0 0 !important;
        }

        .leaflet-control-zoom-out {
            border-radius: 0 0 8px 8px !important;
        }

        /* Attribution */
        .leaflet-control-attribution {
            background: var(--bg-card) !important;
            color: var(--text-secondary) !important;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px 0 0 0;
        }

        .leaflet-control-attribution a {
            color: var(--accent-blue) !important;
        }

        /* Filter button */
        .filter-btn {
            background: linear-gradient(135deg, var(--bg-card), var(--bg-hover));
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 0.6rem 1rem;
            color: var(--text-primary);
            font-family: 'DM Sans', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
        }

        .filter-btn:hover {
            background: linear-gradient(135deg, var(--bg-hover), var(--border-color));
            border-color: var(--accent-orange);
        }

        .filter-btn.active {
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-orange-dark));
            border-color: var(--accent-orange);
            color: var(--btn-active-text);
        }

        .filter-btn.active:hover {
            background: linear-gradient(135deg, var(--accent-orange-dark), var(--accent-orange));
        }

        .filter-icon {
            font-size: 1rem;
        }

        /* Theme toggle button */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .theme-toggle {
            background: linear-gradient(135deg, var(--bg-card), var(--bg-hover));
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 0.6rem;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            width: 42px;
            height: 42px;
        }

        .theme-toggle:hover {
            background: linear-gradient(135deg, var(--bg-hover), var(--border-color));
            border-color: var(--accent-orange);
        }

        .theme-toggle .theme-icon {
            font-size: 1.1rem;
            line-height: 1;
        }

        /* Light mode: show moon (to switch to dark) */
        .theme-toggle .icon-sun { display: none; }
        .theme-toggle .icon-moon { display: block; }

        /* Dark mode: show sun (to switch to light) */
        :root[data-theme="dark"] .theme-toggle .icon-sun { display: block; }
        :root[data-theme="dark"] .theme-toggle .icon-moon { display: none; }

        /* Modal overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-bg);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            width: 90%;
            max-width: 550px;
            max-height: 80vh;
            overflow: hidden;
            transform: scale(0.9) translateY(20px);
            transition: transform 0.3s ease;
            box-shadow: 0 20px 60px var(--shadow-xl);
        }

        .modal-overlay.visible .modal {
            transform: scale(1) translateY(0);
        }

        .modal-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-header h2 {
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
            transition: color 0.2s;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-body p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .email-textarea {
            width: 100%;
            height: 200px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem;
            color: var(--text-primary);
            font-family: 'DM Sans', monospace;
            font-size: 0.85rem;
            resize: vertical;
            transition: border-color 0.2s;
        }

        .email-textarea:focus {
            outline: none;
            border-color: var(--accent-orange);
        }

        .email-textarea::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .modal-footer {
            padding: 1rem 1.5rem 1.5rem;
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.6rem 1.25rem;
            border-radius: 8px;
            font-family: 'DM Sans', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn.secondary {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .modal-btn.secondary:hover {
            border-color: var(--text-secondary);
            color: var(--text-primary);
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-orange-dark));
            border: none;
            color: var(--btn-active-text);
        }

        .modal-btn.primary:hover {
            background: linear-gradient(135deg, var(--accent-orange-dark), var(--accent-orange));
        }

        /* Muted marker styles */
        .marker-pin.muted {
            background: var(--muted-marker) !important;
            opacity: 0.4 !important;
        }

        /* Filter active indicator */
        .filter-count {
            background: var(--accent-red);
            color: white;
            font-size: 0.7rem;
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: row;
                padding: 0.75rem 1rem;
            }

            .logo-icon {
                width: 36px;
                height: 36px;
                font-size: 1.1rem;
                border-radius: 8px;
            }

            .logo-text h1 {
                font-size: 1.1rem;
            }

            .logo-text p {
                display: none;
            }

            .stats {
                display: none;
            }

            .header-actions {
                gap: 0.5rem;
            }

            .theme-toggle {
                width: 36px;
                height: 36px;
                padding: 0.4rem;
            }

            .theme-toggle .theme-icon {
                font-size: 0.95rem;
            }

            .filter-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
            }

            .filter-btn .filter-icon {
                font-size: 0.9rem;
            }

            .legend {
                max-width: 180px;
                padding: 0.6rem;
            }

            .legend h3 {
                margin-bottom: 0.4rem;
                font-size: 0.75rem;
            }

            .legend-item {
                margin-bottom: 0.15rem;
                font-size: 0.7rem;
            }

            #map {
                height: calc(100vh - 54px);
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo-section">
            <div class="logo-icon">üöë</div>
            <div class="logo-text">
                <h1>BCEHS Stations</h1>
                <p>BC Emergency Health Services</p>
            </div>
        </div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="total-stations">-</div>
                <div class="stat-label">Stations</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="total-calls">-</div>
                <div class="stat-label">Total Responses</div>
            </div>
        </div>
        <div class="header-actions">
            <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle dark/light mode">
                <span class="theme-icon">
                    <span class="icon-sun">‚òÄÔ∏è</span>
                    <span class="icon-moon">üåô</span>
                </span>
            </button>
            <button class="filter-btn" id="filterBtn" onclick="toggleFilterModal()">
                <span class="filter-icon">üìã</span>
                <span id="filterBtnText">Filter</span>
            </button>
        </div>
    </header>

    <!-- Filter Modal -->
    <div class="modal-overlay" id="filterModal">
        <div class="modal">
            <div class="modal-header">
                <h2>üìã Paste Station Email</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p>Paste the contents of the monthly station availability email below. The map will highlight only the stations listed in the email. No need to clean up the formatting‚Äîjust paste the raw email text.</p>
                <textarea class="email-textarea" id="emailContent" placeholder="Paste email content here...

Example:
ALERT BAY - 102 Remote
50%

MACKENZIE - 532 Remote
75%
..."></textarea>
            </div>
            <div class="modal-footer">
                <button class="modal-btn secondary" onclick="closeModal()">Cancel</button>
                <button class="modal-btn primary" onclick="applyFilter()">Apply Filter</button>
            </div>
        </div>
    </div>

    <div id="map"></div>

    <div class="legend">
        <h3>Station Types</h3>
        <div class="legend-item">
            <div class="legend-marker station"></div>
            <span>Station</span>
        </div>
        <div class="legend-item">
            <div class="legend-marker annex"></div>
            <span>Annex</span>
        </div>
        <div class="legend-item">
            <div class="legend-marker dispatch"></div>
            <span>Dispatch</span>
        </div>
        <div class="legend-item">
            <div class="legend-marker special"></div>
            <span>Special Ops</span>
        </div>
        <div class="legend-item">
            <div class="legend-marker cct"></div>
            <span>Critical Care</span>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // GeoJSON data
        const stationsData = {
            "type": "FeatureCollection",
            "features": []
        };

        // Wait times data indexed by normalized community name
        let waitTimesData = {};

        // Filter state
        let isFilterActive = false;
        let filteredStationNumbers = new Set();
        let map = null;
        let markersLayer = null;
        let tileLayer = null;

        // Theme management
        function getEffectiveTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) return savedTheme;
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function getTileUrl(theme) {
            const style = (theme || getEffectiveTheme()) === 'dark' ? 'dark_all' : 'light_all';
            return `https://{s}.basemaps.cartocdn.com/${style}/{z}/{x}/{y}{r}.png`;
        }

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            if (tileLayer && map) {
                tileLayer.setUrl(getTileUrl(theme));
            }
        }

        // Toggle theme
        function toggleTheme() {
            const newTheme = getEffectiveTheme() === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        }

        // Initialize theme on page load (applies data-theme for both system pref and saved pref)
        applyTheme(getEffectiveTheme());

        // Listen for system color scheme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            if (!localStorage.getItem('theme')) {
                applyTheme(getEffectiveTheme());
            }
        });

        // Normalize community name for matching
        function normalizeCommunity(name) {
            return name.toLowerCase()
                .replace(/\./g, '')
                .replace(/'/g, '')
                .replace(/[\u00a0]/g, ' ')  // Replace non-breaking spaces
                .replace(/\s*-\s*/g, ' ')   // Replace dash with optional surrounding spaces
                .replace(/\s+/g, ' ')
                .trim();
        }

        // Manual mappings: Station location ‚Üí CSV community name
        // Maps station names to wait time data communities
        const stationToCommunityMap = {
            // Large cities - multiple stations map to single city data
            'kamloops north': 'kamloops',
            'kamloops south': 'kamloops',
            'kamloops dispatch operations centre': 'kamloops',
            'nanaimo south': 'nanaimo',
            'nanaimo north': 'nanaimo',
            'richmond south': 'richmond',
            'richmond north': 'richmond',
            'delta north': 'delta',
            'ladner': 'delta',
            'surrey cloverdale': 'surrey',
            'langley north': 'langley',
            
            // Victoria area stations
            'victoria esquimalt': 'victoria',
            'victoria royal oak': 'victoria',
            'victoria fairfield': 'victoria',
            'victoria central reporting station': 'victoria',
            'shelbourne': 'saanich',
            
            // Vancouver area stations
            'cambie st': 'vancouver',
            'arbutus and 13th': 'vancouver',
            'downtown east side': 'vancouver',
            'east king edward': 'vancouver',
            'west 7th': 'vancouver',
            'ubc': 'vancouver',
            'yvr airport bike squad': 'vancouver',
            'st pauls hospital': 'vancouver',
            'vancouver dispatch': 'vancouver',
            
            // Surrey area
            'surrey memorial hospital': 'surrey',
            
            // Spelling variants / aliases
            'kitwanga': 'gitwangak',
            'quadra island': 'quathiaski cove',
            'pender island': 'north pender island',
            
            // Prince George area
            'prince george edmonton': 'prince george',
            
            // Fort St. James spelling
            'fort st james': 'fort st james',
            
            // Neighborhoods to nearby communities
            'abbotsford mt lehman': 'abbotsford',
            'lions bay': 'west vancouver',
        };

        // Communities with multiple stations (computed after data loads)
        let multiStationCommunities = new Set();

        // Extract community name from station location field
        function extractCommunity(location) {
            if (!location) return '';
            // Remove parenthetical codes like "(ALB)" from "Alert Bay (ALB)"
            const match = location.match(/^([^(]+)/);
            return match ? match[1].trim() : location.trim();
        }

        // Get the CSV community key for a station location
        function getCommunityKey(location) {
            const extracted = extractCommunity(location);
            const normalized = normalizeCommunity(extracted);
            
            // Check manual mapping first
            if (stationToCommunityMap[normalized]) {
                return stationToCommunityMap[normalized];
            }
            
            return normalized;
        }

        // Compute which communities have multiple stations
        function computeMultiStationCommunities() {
            const stationsByCommunity = {};
            stationsData.features.forEach(feature => {
                // Skip Duty Supervisor Group stations
                if (feature.properties.location === 'Duty Supervisor Group') {
                    return;
                }
                const communityKey = getCommunityKey(feature.properties.location);
                if (!stationsByCommunity[communityKey]) {
                    stationsByCommunity[communityKey] = [];
                }
                stationsByCommunity[communityKey].push(feature);
            });

            multiStationCommunities = new Set();
            for (const [key, stations] of Object.entries(stationsByCommunity)) {
                if (stations.length > 1) {
                    multiStationCommunities.add(key);
                }
            }
            console.log(`Found ${multiStationCommunities.size} communities with multiple stations`);
        }

        // Check if station uses aggregate/mapped data (shares data with other stations)
        function isAggregateData(location) {
            const extracted = extractCommunity(location);
            const normalized = normalizeCommunity(extracted);
            const communityKey = getCommunityKey(location);

            // Show aggregate notice if:
            // 1. There's a manual mapping for this station, OR
            // 2. Multiple stations share this community's data
            return stationToCommunityMap.hasOwnProperty(normalized) ||
                   multiStationCommunities.has(communityKey);
        }

        // Get display name for the data source region
        function getDataSourceName(location) {
            const communityKey = getCommunityKey(location);
            // Look up the original community name from the data
            const data = waitTimesData[communityKey];
            if (data && data.community) {
                return data.community;
            }
            // Fallback: capitalize the key
            return communityKey.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        // Parse CSV text into array of objects
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = [];
                let current = '';
                let inQuotes = false;
                
                for (const char of lines[i]) {
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());
                
                const row = {};
                headers.forEach((header, idx) => {
                    row[header.trim()] = values[idx] || '';
                });
                data.push(row);
            }
            return data;
        }

        // Parse number that may have comma separators
        function parseNumber(str) {
            if (!str) return 0;
            return parseInt(str.replace(/,/g, ''), 10) || 0;
        }

        // Index wait times by normalized community name (all years per community)
        function indexWaitTimes(csvData) {
            const indexed = {};
            
            csvData.forEach(row => {
                const community = normalizeCommunity(row.community);
                const year = parseInt(row.year, 10);
                
                if (!indexed[community]) {
                    indexed[community] = {
                        community: row.community,
                        years: {}
                    };
                }
                
                indexed[community].years[year] = {
                    year: year,
                    eventsTotal: parseNumber(row['events-total']),
                    eventsRedPurple: parseNumber(row['events-red_purple']),
                    eventsOrange: parseNumber(row['events-orange']),
                    eventsYellow: parseNumber(row['events-yellow']),
                    medianRedPurple: parseNumber(row['media-seconds-red_purple']),
                    medianOrange: parseNumber(row['median-seconds-orange']),
                    medianYellow: parseNumber(row['median-seconds-yellow'])
                };
            });
            
            return indexed;
        }

        // Get wait time data for a station (all years)
        function getWaitTimeForStation(location) {
            const communityKey = getCommunityKey(location);
            return waitTimesData[communityKey] || null;
        }

        // Get available years for a community (sorted descending)
        function getAvailableYears(communityData) {
            if (!communityData || !communityData.years) return [];
            return Object.keys(communityData.years)
                .map(y => parseInt(y, 10))
                .sort((a, b) => b - a);
        }

        // Get most recent year for a community
        function getMostRecentYear(communityData) {
            const years = getAvailableYears(communityData);
            return years.length > 0 ? years[0] : null;
        }

        // Modal functions
        function toggleFilterModal() {
            if (isFilterActive) {
                clearFilter();
            } else {
                openModal();
            }
        }

        function openModal() {
            document.getElementById('filterModal').classList.add('visible');
            document.getElementById('emailContent').focus();
        }

        function closeModal() {
            document.getElementById('filterModal').classList.remove('visible');
            document.getElementById('emailContent').value = '';
        }

        function parseEmailForStations(emailText) {
            const stationNumbers = new Set();
            // Match patterns like "STATION NAME - 123 Type" or "station name - 123 type"
            const regex = /[\w\s'\.]+\s*-\s*(\d+)\s+(?:Urban|Rural|Remote)/gi;
            let match;
            while ((match = regex.exec(emailText)) !== null) {
                stationNumbers.add(parseInt(match[1], 10));
            }
            return stationNumbers;
        }

        function applyFilter() {
            const emailText = document.getElementById('emailContent').value;
            filteredStationNumbers = parseEmailForStations(emailText);

            if (filteredStationNumbers.size === 0) {
                alert('No stations found in the pasted content. Make sure the email contains entries like "STATION NAME - 123 Remote"');
                return;
            }

            isFilterActive = true;
            closeModal();
            updateFilterButton();
            refreshMarkers();
        }

        function clearFilter() {
            isFilterActive = false;
            filteredStationNumbers.clear();
            updateFilterButton();
            refreshMarkers();
        }

        function updateFilterButton() {
            const btn = document.getElementById('filterBtn');
            const btnText = document.getElementById('filterBtnText');

            if (isFilterActive) {
                btn.classList.add('active');
                btnText.innerHTML = `Clear Filter <span class="filter-count">${filteredStationNumbers.size}</span>`;
            } else {
                btn.classList.remove('active');
                btnText.textContent = 'Filter';
            }
        }

        // Load both GeoJSON and CSV data
        Promise.all([
            fetch('stations.geojson').then(r => r.json()),
            fetch('https://raw.githubusercontent.com/vs-postmedia/bcehs-wait-times/f371f04cbe42f1738d7886ad6ca23aceb210e5d9/data/bcehs-wait-times.csv').then(r => r.text())
        ])
            .then(([geoData, csvText]) => {
                stationsData.features = geoData.features;
                const csvData = parseCSV(csvText);
                waitTimesData = indexWaitTimes(csvData);
                console.log(`Loaded ${Object.keys(waitTimesData).length} communities with wait time data`);
                computeMultiStationCommunities();
                initMap();
            })
            .catch(error => {
                console.error('Error loading data:', error);
            });

        function initMap() {
            // Update stats (exclude Duty Supervisor Group stations)
            const displayedStations = stationsData.features.filter(f => f.properties.location !== 'Duty Supervisor Group');
            document.getElementById('total-stations').textContent = displayedStations.length;
            
            // Calculate total calls using most recent year for each community
            const totalCalls = Object.values(waitTimesData).reduce((sum, community) => {
                const mostRecentYear = getMostRecentYear(community);
                if (mostRecentYear && community.years[mostRecentYear]) {
                    return sum + community.years[mostRecentYear].eventsTotal;
                }
                return sum;
            }, 0);
            document.getElementById('total-calls').textContent = totalCalls.toLocaleString();

            // Initialize map centered on BC
            map = L.map('map', {
                zoomControl: true
            }).setView([53.7267, -127.6476], 5);

            // Add tile layer (automatically picks light/dark based on system preference)
            tileLayer = L.tileLayer(getTileUrl(), {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> | &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);

            // Create markers layer
            markersLayer = L.layerGroup().addTo(map);

            // Move legend into Leaflet's bottom-left control container
            const legendEl = document.querySelector('.legend');
            const bottomLeft = document.querySelector('.leaflet-bottom.leaflet-left');
            if (legendEl && bottomLeft) {
                bottomLeft.appendChild(legendEl);
            }

            // Add markers
            addMarkersToMap();

            // Fit bounds to show all markers
            fitMapBounds();
        }

        // Get marker type based on tags
        function getMarkerType(tags) {
            if (tags.includes('cct')) return 'cct';
            if (tags.includes('dispatch')) return 'dispatch';
            if (tags.includes('special') || tags.includes('crs')) return 'special';
            if (tags.includes('annex')) return 'annex';
            return 'station';
        }

        // Check if a station is "basic" (no special designations)
        function isBasicStation(tags) {
            const specialTags = ['cct', 'dispatch', 'special', 'crs', 'annex'];
            const filteredTags = tags.filter(t => t && t.trim() !== '');
            return !filteredTags.some(t => specialTags.includes(t));
        }

        // Create custom icon
        function createCustomIcon(type, colocatedCount = 0, isMuted = false) {
            const badgeHtml = colocatedCount > 0
                ? `<div class="marker-badge">+${colocatedCount}</div>`
                : '';

            const mutedClass = isMuted ? ' muted' : '';

            return L.divIcon({
                className: 'custom-marker',
                html: `<div class="custom-marker-wrapper"><div class="marker-pin ${type}${mutedClass}"><div class="marker-inner"></div></div>${badgeHtml}</div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 24],
                popupAnchor: [0, -24]
            });
        }

        // Check if a station should be highlighted
        function isStationHighlighted(stationNumber) {
            if (!isFilterActive) return true;
            return filteredStationNumbers.has(stationNumber);
        }

        // Check if any station in a group is highlighted
        function isGroupHighlighted(stations) {
            if (!isFilterActive) return true;
            return stations.some(s => filteredStationNumbers.has(s.properties.number));
        }

        // Refresh markers with current filter state
        function refreshMarkers() {
            markersLayer.clearLayers();
            addMarkersToMap();
        }

        // Fit map to marker bounds
        function fitMapBounds() {
            const locationGroups = groupStationsByLocation();
            const uniqueCoords = Object.keys(locationGroups).map(key => {
                const [lng, lat] = key.split(',').map(Number);
                return L.marker([lat, lng]);
            });
            const group = L.featureGroup(uniqueCoords);
            map.fitBounds(group.getBounds().pad(0.1));
        }

        // Group stations by coordinates
        function groupStationsByLocation() {
            const locationGroups = {};
            stationsData.features.forEach(feature => {
                // Skip Duty Supervisor Group stations
                if (feature.properties.location === 'Duty Supervisor Group') {
                    return;
                }
                const coordKey = feature.geometry.coordinates.join(',');
                if (!locationGroups[coordKey]) {
                    locationGroups[coordKey] = [];
                }
                locationGroups[coordKey].push(feature);
            });
            return locationGroups;
        }

        const tagLabels = {
            'cp': 'Community Paramedic',
            'soc': 'Scheduled On-Call',
            'annex': 'Annex',
            'dispatch': 'Dispatch',
            'special': 'Special Ops',
            'cct': 'Critical Care',
            'crs': 'Central Reporting',
            'laat': 'LAAT'
        };

        // Get emoji for station type
        function getStationEmoji(markerType) {
            switch (markerType) {
                case 'cct': return 'üöÅ';      // Critical Care Transport - helicopter
                case 'dispatch': return 'üì°'; // Dispatch - satellite
                case 'annex': return 'üèöÔ∏è';    // Annex - decrepit building
                case 'special': return 'üöë';  // Special Ops
                default: return 'üöë';         // Regular station
            }
        }

        // Format seconds as human-readable time
        function formatResponseTime(seconds) {
            if (!seconds || seconds === 0) return '-';
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            if (mins === 0) return `${secs}s`;
            return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
        }

        // Format large numbers with commas
        function formatNumber(num) {
            if (!num) return '0';
            return num.toLocaleString();
        }

        // Generate unique ID for popup elements
        let popupIdCounter = 0;
        function generatePopupId() {
            return `popup-${++popupIdCounter}`;
        }

        // Create wait times HTML section with year selector
        function createWaitTimesHtml(communityData, popupId, stationLocation) {
            if (!communityData || !communityData.years) return '';
            
            const years = getAvailableYears(communityData);
            if (years.length === 0) return '';
            
            const mostRecentYear = years[0];
            const waitData = communityData.years[mostRecentYear];
            // Use the mapped community key for data lookups
            const communityKey = getCommunityKey(stationLocation);
            
            // Check if this is aggregate data for a region
            const isAggregate = isAggregateData(stationLocation);
            const regionName = isAggregate ? getDataSourceName(stationLocation) : null;
            
            // Create year selector dropdown
            const yearOptionsHtml = years.map(year => 
                `<option value="${year}"${year === mostRecentYear ? ' selected' : ''}>${year}</option>`
            ).join('');
            
            // Aggregate data notice
            const aggregateNotice = isAggregate 
                ? `<div class="aggregate-notice">
                       <span class="aggregate-icon">üìç</span>
                       <span class="aggregate-text">Showing data for <strong>${regionName}</strong> region</span>
                   </div>`
                : '';
            
            return `
                <div class="wait-times-section" id="${popupId}">
                    <div class="wait-times-header">
                        <span class="wait-times-title">üìä Response Data</span>
                        <div class="year-selector">
                            <select class="year-select" onchange="switchYear('${popupId}', '${communityKey}', parseInt(this.value))">
                                ${yearOptionsHtml}
                            </select>
                        </div>
                    </div>
                    ${aggregateNotice}
                    <div class="wait-times-total-row">
                        <span class="wait-times-total" id="${popupId}-total">${formatNumber(waitData.eventsTotal)} calls</span>
                    </div>
                    <div class="wait-times-grid" id="${popupId}-grid">
                        ${createWaitTimesGridHtml(waitData)}
                    </div>
                </div>
            `;
        }

        // Create just the grid content (for updating)
        function createWaitTimesGridHtml(waitData) {
            return `
                <div class="wait-time-item priority-red">
                    <div class="priority-label">üî¥ Critical</div>
                    <div class="priority-stats">
                        <span class="event-count">${formatNumber(waitData.eventsRedPurple)}</span>
                        <span class="response-time">${formatResponseTime(waitData.medianRedPurple)}</span>
                    </div>
                </div>
                <div class="wait-time-item priority-orange">
                    <div class="priority-label">üü† Urgent</div>
                    <div class="priority-stats">
                        <span class="event-count">${formatNumber(waitData.eventsOrange)}</span>
                        <span class="response-time">${formatResponseTime(waitData.medianOrange)}</span>
                    </div>
                </div>
                <div class="wait-time-item priority-yellow">
                    <div class="priority-label">üü° Routine</div>
                    <div class="priority-stats">
                        <span class="event-count">${formatNumber(waitData.eventsYellow)}</span>
                        <span class="response-time">${formatResponseTime(waitData.medianYellow)}</span>
                    </div>
                </div>
            `;
        }

        // Switch year in popup
        function switchYear(popupId, communityKey, year) {
            const communityData = waitTimesData[communityKey];
            if (!communityData || !communityData.years[year]) return;
            
            const waitData = communityData.years[year];
            
            // Update grid content
            const gridEl = document.getElementById(`${popupId}-grid`);
            if (gridEl) {
                gridEl.innerHTML = createWaitTimesGridHtml(waitData);
            }
            
            // Update total
            const totalEl = document.getElementById(`${popupId}-total`);
            if (totalEl) {
                totalEl.textContent = `${formatNumber(waitData.eventsTotal)} calls`;
            }
        }

        // Create popup content for a single station
        function createSingleStationPopup(props) {
            const markerType = getMarkerType(props.tags || []);
            const tags = (props.tags || []).filter(t => t && t.trim() !== '');
            const communityData = getWaitTimeForStation(props.location);
            const popupId = generatePopupId();

            const tagsHtml = tags.map(tag =>
                `<span class="tag tag-${tag}">${tagLabels[tag] || tag}</span>`
            ).join('');

            return `
                <div class="popup-content">
                    <div class="popup-header">
                        <div class="popup-icon ${markerType}">${getStationEmoji(markerType)}</div>
                        <div>
                            <div class="popup-title">${props.title || props.station}</div>
                            <div class="popup-location">${props.location || ''}</div>
                        </div>
                    </div>
                    <div class="popup-address">${props.address || 'Address not available'}</div>
                    ${tagsHtml ? `<div class="popup-tags">${tagsHtml}</div>` : ''}
                    ${createWaitTimesHtml(communityData, popupId, props.location)}
                </div>
            `;
        }

        // Create popup content for co-located stations
        function createColocatedPopup(primaryStation, colocatedStations) {
            const primaryProps = primaryStation.properties;
            const primaryMarkerType = getMarkerType(primaryProps.tags || []);
            const primaryTags = (primaryProps.tags || []).filter(t => t && t.trim() !== '');
            const popupId = generatePopupId();
            
            // Find wait time data from ANY station at this location
            const allStations = [primaryStation, ...colocatedStations];
            let communityData = null;
            let dataSourceLocation = null;
            for (const station of allStations) {
                const data = getWaitTimeForStation(station.properties.location);
                if (data && Object.keys(data.years || {}).length > 0) {
                    communityData = data;
                    dataSourceLocation = station.properties.location;
                    break;
                }
            }

            const primaryTagsHtml = primaryTags.map(tag =>
                `<span class="tag tag-${tag}">${tagLabels[tag] || tag}</span>`
            ).join('');

            // Build co-located groups HTML
            const colocatedHtml = colocatedStations.map(station => {
                const props = station.properties;
                const type = getMarkerType(props.tags || []);
                const tags = (props.tags || []).filter(t => t && t.trim() !== '');
                const tagsHtml = tags.map(tag =>
                    `<span class="tag tag-${tag}">${tagLabels[tag] || tag}</span>`
                ).join('');

                return `
                    <div class="colocated-group">
                        <div class="colocated-group-header">
                            <div class="colocated-icon ${type}">${getStationEmoji(type)}</div>
                            <div class="colocated-name">${props.title || props.station}</div>
                        </div>
                        ${tagsHtml ? `<div class="colocated-tags">${tagsHtml}</div>` : ''}
                    </div>
                `;
            }).join('');

            return `
                <div class="popup-content">
                    <div class="popup-header">
                        <div class="popup-icon ${primaryMarkerType}">${getStationEmoji(primaryMarkerType)}</div>
                        <div>
                            <div class="popup-title">${primaryProps.title || primaryProps.station}</div>
                            <div class="popup-location">${primaryProps.location || ''}</div>
                        </div>
                    </div>
                    <div class="popup-address">${primaryProps.address || 'Address not available'}</div>
                    ${primaryTagsHtml ? `<div class="popup-tags">${primaryTagsHtml}</div>` : ''}
                    <div class="colocated-section">
                        <div class="colocated-title">Also at this location</div>
                        ${colocatedHtml}
                    </div>
                    ${createWaitTimesHtml(communityData, popupId, dataSourceLocation || primaryProps.location)}
                </div>
            `;
        }

        // Add markers to the map
        function addMarkersToMap() {
            const locationGroups = groupStationsByLocation();

            // Add markers for each unique location
            Object.values(locationGroups).forEach(stations => {
                if (stations.length === 1) {
                    // Single station at this location
                    const feature = stations[0];
                    const coords = feature.geometry.coordinates;
                    const props = feature.properties;
                    const markerType = getMarkerType(props.tags || []);
                    const isMuted = !isStationHighlighted(props.number);

                    const marker = L.marker([coords[1], coords[0]], {
                        icon: createCustomIcon(markerType, 0, isMuted)
                    }).addTo(markersLayer);

                    marker.bindPopup(createSingleStationPopup(props), {
                        maxWidth: 320,
                        className: 'custom-popup'
                    });
                } else {
                    // Multiple stations at this location
                    // Sort by priority: dispatch > cct > crs > no tags > lower station number
                    const getPriority = (tags) => {
                        if (tags.includes('dispatch')) return 0;
                        if (tags.includes('cct')) return 1;
                        if (tags.includes('crs')) return 2;
                        // Check if station has no special tags (basic station)
                        if (isBasicStation(tags)) return 3;
                        // Other special tags (annex, special, etc.) come after basic
                        return 4;
                    };

                    const sorted = [...stations].sort((a, b) => {
                        const aTags = a.properties.tags || [];
                        const bTags = b.properties.tags || [];
                        const aPriority = getPriority(aTags);
                        const bPriority = getPriority(bTags);
                        if (aPriority !== bPriority) return aPriority - bPriority;
                        return (a.properties.number || 999) - (b.properties.number || 999);
                    });

                    const primaryStation = sorted[0];
                    const colocatedStations = sorted.slice(1);
                    const coords = primaryStation.geometry.coordinates;
                    const markerType = getMarkerType(primaryStation.properties.tags || []);
                    const isMuted = !isGroupHighlighted(stations);

                    const marker = L.marker([coords[1], coords[0]], {
                        icon: createCustomIcon(markerType, colocatedStations.length, isMuted)
                    }).addTo(markersLayer);

                    marker.bindPopup(createColocatedPopup(primaryStation, colocatedStations), {
                        maxWidth: 320,
                        className: 'custom-popup'
                    });
                }
            });
        }
    </script>
</body>
</html>

